// Code generated by go-enum
// DO NOT EDIT!

package node_semver

import (
	"fmt"
)

const (
	// TokenizeResultValueNone is a TokenizeResultValue of type None.
	TokenizeResultValueNone TokenizeResultValue = iota
	// TokenizeResultValueVersion is a TokenizeResultValue of type Version.
	TokenizeResultValueVersion
	// TokenizeResultValueRange is a TokenizeResultValue of type Range.
	TokenizeResultValueRange
)

const _TokenizeResultValueName = "NoneVersionRange"

var _TokenizeResultValueMap = map[TokenizeResultValue]string{
	0: _TokenizeResultValueName[0:4],
	1: _TokenizeResultValueName[4:11],
	2: _TokenizeResultValueName[11:16],
}

// String implements the Stringer interface.
func (x TokenizeResultValue) String() string {
	if str, ok := _TokenizeResultValueMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TokenizeResultValue(%d)", x)
}

var _TokenizeResultValueValue = map[string]TokenizeResultValue{
	_TokenizeResultValueName[0:4]:   0,
	_TokenizeResultValueName[4:11]:  1,
	_TokenizeResultValueName[11:16]: 2,
}

// ParseTokenizeResultValue attempts to convert a string to a TokenizeResultValue
func ParseTokenizeResultValue(name string) (TokenizeResultValue, error) {
	if x, ok := _TokenizeResultValueValue[name]; ok {
		return x, nil
	}
	return TokenizeResultValue(0), fmt.Errorf("%s is not a valid TokenizeResultValue", name)
}

// MarshalText implements the text marshaller method
func (x TokenizeResultValue) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *TokenizeResultValue) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTokenizeResultValue(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// VersionLevelMajor is a VersionLevel of type Major.
	VersionLevelMajor VersionLevel = iota
	// VersionLevelMinor is a VersionLevel of type Minor.
	VersionLevelMinor
	// VersionLevelPatch is a VersionLevel of type Patch.
	VersionLevelPatch
	// VersionLevelPrerelease is a VersionLevel of type Prerelease.
	VersionLevelPrerelease
	// VersionLevelPrepatch is a VersionLevel of type Prepatch.
	VersionLevelPrepatch
	// VersionLevelPreminor is a VersionLevel of type Preminor.
	VersionLevelPreminor
	// VersionLevelPremajor is a VersionLevel of type Premajor.
	VersionLevelPremajor
)

const _VersionLevelName = "MajorMinorPatchPrereleasePrepatchPreminorPremajor"

var _VersionLevelMap = map[VersionLevel]string{
	0: _VersionLevelName[0:5],
	1: _VersionLevelName[5:10],
	2: _VersionLevelName[10:15],
	3: _VersionLevelName[15:25],
	4: _VersionLevelName[25:33],
	5: _VersionLevelName[33:41],
	6: _VersionLevelName[41:49],
}

// String implements the Stringer interface.
func (x VersionLevel) String() string {
	if str, ok := _VersionLevelMap[x]; ok {
		return str
	}
	return fmt.Sprintf("VersionLevel(%d)", x)
}

var _VersionLevelValue = map[string]VersionLevel{
	_VersionLevelName[0:5]:   0,
	_VersionLevelName[5:10]:  1,
	_VersionLevelName[10:15]: 2,
	_VersionLevelName[15:25]: 3,
	_VersionLevelName[25:33]: 4,
	_VersionLevelName[33:41]: 5,
	_VersionLevelName[41:49]: 6,
}

// ParseVersionLevel attempts to convert a string to a VersionLevel
func ParseVersionLevel(name string) (VersionLevel, error) {
	if x, ok := _VersionLevelValue[name]; ok {
		return x, nil
	}
	return VersionLevel(0), fmt.Errorf("%s is not a valid VersionLevel", name)
}

// MarshalText implements the text marshaller method
func (x VersionLevel) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *VersionLevel) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseVersionLevel(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// SevmerTokenTypeNone is a sevmerTokenType of type None.
	SevmerTokenTypeNone sevmerTokenType = iota
	// SevmerTokenTypeOR is a sevmerTokenType of type OR.
	SevmerTokenTypeOR
	// SevmerTokenTypeGT is a sevmerTokenType of type GT.
	SevmerTokenTypeGT
	// SevmerTokenTypeGE is a sevmerTokenType of type GE.
	SevmerTokenTypeGE
	// SevmerTokenTypeLT is a sevmerTokenType of type LT.
	SevmerTokenTypeLT
	// SevmerTokenTypeLE is a sevmerTokenType of type LE.
	SevmerTokenTypeLE
	// SevmerTokenTypeVersion is a sevmerTokenType of type Version.
	SevmerTokenTypeVersion
	// SevmerTokenTypeTilda is a sevmerTokenType of type Tilda.
	SevmerTokenTypeTilda
	// SevmerTokenTypeCaret is a sevmerTokenType of type Caret.
	SevmerTokenTypeCaret
)

const _sevmerTokenTypeName = "NoneORGTGELTLEVersionTildaCaret"

var _sevmerTokenTypeMap = map[sevmerTokenType]string{
	0: _sevmerTokenTypeName[0:4],
	1: _sevmerTokenTypeName[4:6],
	2: _sevmerTokenTypeName[6:8],
	3: _sevmerTokenTypeName[8:10],
	4: _sevmerTokenTypeName[10:12],
	5: _sevmerTokenTypeName[12:14],
	6: _sevmerTokenTypeName[14:21],
	7: _sevmerTokenTypeName[21:26],
	8: _sevmerTokenTypeName[26:31],
}

// String implements the Stringer interface.
func (x sevmerTokenType) String() string {
	if str, ok := _sevmerTokenTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("sevmerTokenType(%d)", x)
}

var _sevmerTokenTypeValue = map[string]sevmerTokenType{
	_sevmerTokenTypeName[0:4]:   0,
	_sevmerTokenTypeName[4:6]:   1,
	_sevmerTokenTypeName[6:8]:   2,
	_sevmerTokenTypeName[8:10]:  3,
	_sevmerTokenTypeName[10:12]: 4,
	_sevmerTokenTypeName[12:14]: 5,
	_sevmerTokenTypeName[14:21]: 6,
	_sevmerTokenTypeName[21:26]: 7,
	_sevmerTokenTypeName[26:31]: 8,
}

// ParsesevmerTokenType attempts to convert a string to a sevmerTokenType
func ParsesevmerTokenType(name string) (sevmerTokenType, error) {
	if x, ok := _sevmerTokenTypeValue[name]; ok {
		return x, nil
	}
	return sevmerTokenType(0), fmt.Errorf("%s is not a valid sevmerTokenType", name)
}

// MarshalText implements the text marshaller method
func (x sevmerTokenType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *sevmerTokenType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsesevmerTokenType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
